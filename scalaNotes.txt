* call-by-value VS call-by-name
  def function(byValue : Int, byName : => Int) = ...

  def = by name
    def x = square(22) => evaluated at each use
  val = by value
    val x = square(22) => evaluated only once

* lexical scope
  { ... } = is an expression!
  definitions from outside the block are visible inside the block
  definitions inside the block shadows definitions from outside the block
  definitions inside the block are not visible outside the block

* Multiple parameter lists - shortcut for function that return a function - for currying
  def sum(f: Int => Int)(a: Int, b: Int): Int   ===   def sum(f: Int => Int): (Int, Int) => Int
  usage: sum (cube) (10, 20)









  Videos:
  * Panel on the Past, Present, and Future of Scala (1h15min) = https://www.youtube.com/watch?v=xUWNcL7NRxg
  * Spark -- the Ultimate Scala Collections (44min) = https://www.youtube.com/watch?v=NW5h8d_ZyOs

  * Functional Programming Vs Imperative Programming =
    in imperative you think about Time = first the processor will do this, then that
      parallelism is hard = you need to synchronize processes using control structures like locks, atomics, software transactional memory to rule out bad combinations of threads
    in functional you thing about Space = first I construct this, then that, and then I will construct the third thing from first and second
      easy parallelism = you just build different parts of your final construct on different processes








????? For Future ?????
* Parallel Collections
* Distributed Collections
* Actors = Akka
* DSLs = scala parser combinators
  http://bitwalker.org/posts/2013-08-10-learn-by-example-scala-parser-combinators/
  https://wiki.scala-lang.org/display/SW/Parser+Combinators--Getting+Started
  https://github.com/scala/scala-parser-combinators/blob/1.0.x/docs/Getting_Started.md
  http://debasishg.blogspot.com/2008/04/external-dsls-made-easy-with-scala.html
